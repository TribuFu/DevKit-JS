//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { TribufuApiBase } from "./api.base";

export class TribufuApiGenerated extends TribufuApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getUserInfo(): Promise<UserInfo> {
        let url_ = this.baseUrl + "/v1/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserInfo(_response);
        });
    }

    protected processGetUserInfo(response: Response): Promise<UserInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserInfo;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginRequest | undefined): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/v1/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: RegisterRequest | undefined): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/v1/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    refresh(body: RefreshRequest | undefined): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/v1/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    /**
     * @return OK
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/v1/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @return OK
     */
    getClusters(page: number | undefined): Promise<GameServerCluster[]> {
        let url_ = this.baseUrl + "/v1/clusters?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClusters(_response);
        });
    }

    protected processGetClusters(response: Response): Promise<GameServerCluster[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GameServerCluster[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameServerCluster[]>(null as any);
    }

    /**
     * @return OK
     */
    getClusterGetById(id: string): Promise<GameServerCluster> {
        let url_ = this.baseUrl + "/v1/clusters/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClusterGetById(_response);
        });
    }

    protected processGetClusterGetById(response: Response): Promise<GameServerCluster> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GameServerCluster;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameServerCluster>(null as any);
    }

    /**
     * @param page (optional) 
     * @return OK
     */
    getFiles(page: number | undefined): Promise<File[]> {
        let url_ = this.baseUrl + "/v1/files?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFiles(_response);
        });
    }

    protected processGetFiles(response: Response): Promise<File[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as File[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File[]>(null as any);
    }

    /**
     * @return OK
     */
    getFileById(id: string): Promise<File> {
        let url_ = this.baseUrl + "/v1/files/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFileById(_response);
        });
    }

    protected processGetFileById(response: Response): Promise<File> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as File;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File>(null as any);
    }

    /**
     * @return OK
     */
    getGames(): Promise<Game[]> {
        let url_ = this.baseUrl + "/v1/games";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGames(_response);
        });
    }

    protected processGetGames(response: Response): Promise<Game[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Game[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Game[]>(null as any);
    }

    /**
     * @return OK
     */
    getGameById(id: string): Promise<Game> {
        let url_ = this.baseUrl + "/v1/games/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGameById(_response);
        });
    }

    protected processGetGameById(response: Response): Promise<Game> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Game;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Game>(null as any);
    }

    /**
     * @param page (optional) 
     * @return OK
     */
    getGameServers(id: string, page: number | undefined): Promise<GameServer[]> {
        let url_ = this.baseUrl + "/v1/games/{id}/servers?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGameServers(_response);
        });
    }

    protected processGetGameServers(response: Response): Promise<GameServer[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GameServer[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameServer[]>(null as any);
    }

    /**
     * @param page (optional) 
     * @return OK
     */
    getGameClusters(id: string, page: number | undefined): Promise<GameServerCluster[]> {
        let url_ = this.baseUrl + "/v1/games/{id}/clusters?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGameClusters(_response);
        });
    }

    protected processGetGameClusters(response: Response): Promise<GameServerCluster[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GameServerCluster[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameServerCluster[]>(null as any);
    }

    /**
     * @param uuid (optional) 
     * @param tag (optional) 
     * @param name (optional) 
     * @param email (optional) 
     * @param page (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getGroups(uuid: string | undefined, tag: string | undefined, name: string | undefined, email: string | undefined, page: number | undefined, limit: number | undefined): Promise<Group[]> {
        let url_ = this.baseUrl + "/v1/groups?";
        if (uuid === null)
            throw new Error("The parameter 'uuid' cannot be null.");
        else if (uuid !== undefined)
            url_ += "uuid=" + encodeURIComponent("" + uuid) + "&";
        if (tag === null)
            throw new Error("The parameter 'tag' cannot be null.");
        else if (tag !== undefined)
            url_ += "tag=" + encodeURIComponent("" + tag) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroups(_response);
        });
    }

    protected processGetGroups(response: Response): Promise<Group[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Group[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Group[]>(null as any);
    }

    /**
     * @return OK
     */
    getGroupById(id: string): Promise<Group> {
        let url_ = this.baseUrl + "/v1/groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroupById(_response);
        });
    }

    protected processGetGroupById(response: Response): Promise<Group> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Group;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Group>(null as any);
    }

    /**
     * @return OK
     */
    getGroupMembers(id: string): Promise<GroupMember[]> {
        let url_ = this.baseUrl + "/v1/groups/{id}/members";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroupMembers(_response);
        });
    }

    protected processGetGroupMembers(response: Response): Promise<GroupMember[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GroupMember[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupMember[]>(null as any);
    }

    /**
     * @return OK
     */
    getGroupGames(id: string): Promise<GroupGame[]> {
        let url_ = this.baseUrl + "/v1/groups/{id}/games";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroupGames(_response);
        });
    }

    protected processGetGroupGames(response: Response): Promise<GroupGame[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GroupGame[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupGame[]>(null as any);
    }

    /**
     * @param order (optional) 
     * @return OK
     */
    getLeaderboard(order: LeaderboardOrder | undefined): Promise<LeaderboardItem[]> {
        let url_ = this.baseUrl + "/v1/leaderboard?";
        if (order === null)
            throw new Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetLeaderboard(_response);
        });
    }

    protected processGetLeaderboard(response: Response): Promise<LeaderboardItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LeaderboardItem[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeaderboardItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    search(body: SearchRequest | undefined): Promise<any[]> {
        let url_ = this.baseUrl + "/v1/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<any[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any[]>(null as any);
    }

    /**
     * @param address (optional) 
     * @param query_port (optional) 
     * @param country (optional) 
     * @param page (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getServers(address: string | undefined, query_port: number | undefined, country: string | undefined, page: number | undefined, limit: number | undefined): Promise<GameServer[]> {
        let url_ = this.baseUrl + "/v1/servers?";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        if (query_port === null)
            throw new Error("The parameter 'query_port' cannot be null.");
        else if (query_port !== undefined)
            url_ += "query_port=" + encodeURIComponent("" + query_port) + "&";
        if (country === null)
            throw new Error("The parameter 'country' cannot be null.");
        else if (country !== undefined)
            url_ += "country=" + encodeURIComponent("" + country) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetServers(_response);
        });
    }

    protected processGetServers(response: Response): Promise<GameServer[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GameServer[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameServer[]>(null as any);
    }

    /**
     * @return OK
     */
    getServerById(id: string): Promise<GameServer> {
        let url_ = this.baseUrl + "/v1/servers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetServerById(_response);
        });
    }

    protected processGetServerById(response: Response): Promise<GameServer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GameServer;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameServer>(null as any);
    }

    /**
     * @return OK
     */
    getServersMetrics(): Promise<ServerMetrics> {
        let url_ = this.baseUrl + "/v1/servers/metrics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetServersMetrics(_response);
        });
    }

    protected processGetServersMetrics(response: Response): Promise<ServerMetrics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServerMetrics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerMetrics>(null as any);
    }

    /**
     * @return OK
     */
    getServersCountries(): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/v1/servers/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetServersCountries(_response);
        });
    }

    protected processGetServersCountries(response: Response): Promise<{ [key: string]: number; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: number; };
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    /**
     * @param page (optional) 
     * @return OK
     */
    getSubscriptions(page: number | undefined): Promise<Subscription[]> {
        let url_ = this.baseUrl + "/v1/subscriptions?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSubscriptions(_response);
        });
    }

    protected processGetSubscriptions(response: Response): Promise<Subscription[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Subscription[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subscription[]>(null as any);
    }

    /**
     * @return OK
     */
    getSubscriptionById(id: string): Promise<Subscription> {
        let url_ = this.baseUrl + "/v1/subscriptions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSubscriptionById(_response);
        });
    }

    protected processGetSubscriptionById(response: Response): Promise<Subscription> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Subscription;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subscription>(null as any);
    }

    /**
     * @param uuid (optional) 
     * @param name (optional) 
     * @param email (optional) 
     * @param page (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getUsers(uuid: string | undefined, name: string | undefined, email: string | undefined, page: number | undefined, limit: number | undefined): Promise<Profile[]> {
        let url_ = this.baseUrl + "/v1/users?";
        if (uuid === null)
            throw new Error("The parameter 'uuid' cannot be null.");
        else if (uuid !== undefined)
            url_ += "uuid=" + encodeURIComponent("" + uuid) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: Response): Promise<Profile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile[]>(null as any);
    }

    /**
     * @return OK
     */
    getUserById(id: string): Promise<Profile> {
        let url_ = this.baseUrl + "/v1/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserById(_response);
        });
    }

    protected processGetUserById(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile>(null as any);
    }

    /**
     * @return OK
     */
    getUserGroups(id: string): Promise<ProfileGroup[]> {
        let url_ = this.baseUrl + "/v1/users/{id}/groups";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserGroups(_response);
        });
    }

    protected processGetUserGroups(response: Response): Promise<ProfileGroup[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProfileGroup[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProfileGroup[]>(null as any);
    }

    /**
     * @return OK
     */
    getUserGames(id: string): Promise<ProfileGame[]> {
        let url_ = this.baseUrl + "/v1/users/{id}/games";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserGames(_response);
        });
    }

    protected processGetUserGames(response: Response): Promise<ProfileGame[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProfileGame[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProfileGame[]>(null as any);
    }

    /**
     * @return OK
     */
    getUserFriends(id: string): Promise<any[]> {
        let url_ = this.baseUrl + "/v1/users/{id}/friends";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserFriends(_response);
        });
    }

    protected processGetUserFriends(response: Response): Promise<any[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any[]>(null as any);
    }

    /**
     * @param page (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getUserServers(id: string, page: number | undefined, limit: number | undefined): Promise<GameServer[]> {
        let url_ = this.baseUrl + "/v1/users/{id}/servers?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserServers(_response);
        });
    }

    protected processGetUserServers(response: Response): Promise<GameServer[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GameServer[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameServer[]>(null as any);
    }

    /**
     * @return OK
     */
    getUserAccounts(id: string): Promise<Account[]> {
        let url_ = this.baseUrl + "/v1/users/{id}/accounts";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserAccounts(_response);
        });
    }

    protected processGetUserAccounts(response: Response): Promise<Account[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Account[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account[]>(null as any);
    }

    /**
     * @return OK
     */
    getUserPunishments(id: string): Promise<any[]> {
        let url_ = this.baseUrl + "/v1/users/{id}/punishments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserPunishments(_response);
        });
    }

    protected processGetUserPunishments(response: Response): Promise<any[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateUserProfile(id: string, body: UpdateProfile | undefined): Promise<Profile> {
        let url_ = this.baseUrl + "/v1/users/{id}/profile";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateUserProfile(_response);
        });
    }

    protected processUpdateUserProfile(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Profile;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile>(null as any);
    }

    /**
     * @param length (optional) 
     * @param symbols (optional) 
     * @return OK
     */
    generatePassword(length: number | undefined, symbols: boolean | undefined): Promise<HashViewModel> {
        let url_ = this.baseUrl + "/v1/utils/password?";
        if (length === null)
            throw new Error("The parameter 'length' cannot be null.");
        else if (length !== undefined)
            url_ += "length=" + encodeURIComponent("" + length) + "&";
        if (symbols === null)
            throw new Error("The parameter 'symbols' cannot be null.");
        else if (symbols !== undefined)
            url_ += "symbols=" + encodeURIComponent("" + symbols) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGeneratePassword(_response);
        });
    }

    protected processGeneratePassword(response: Response): Promise<HashViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HashViewModel;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HashViewModel>(null as any);
    }

    /**
     * @param amount (optional) 
     * @return OK
     */
    generateFlakeId(amount: number | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/v1/utils/flake?";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGenerateFlakeId(_response);
        });
    }

    protected processGenerateFlakeId(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param version (optional) 
     * @param amount (optional) 
     * @return OK
     */
    generateUuid(version: number | undefined, amount: number | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/v1/utils/uuid?";
        if (version === null)
            throw new Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGenerateUuid(_response);
        });
    }

    protected processGenerateUuid(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    convertBase64(body: CryptoViewModel | undefined): Promise<CryptoViewModel> {
        let url_ = this.baseUrl + "/v1/utils/base64";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConvertBase64(_response);
        });
    }

    protected processConvertBase64(response: Response): Promise<CryptoViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CryptoViewModel;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CryptoViewModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    convertMd5(body: HashViewModel | undefined): Promise<HashViewModel> {
        let url_ = this.baseUrl + "/v1/utils/md5";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConvertMd5(_response);
        });
    }

    protected processConvertMd5(response: Response): Promise<HashViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HashViewModel;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HashViewModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    convertSha256(body: HashViewModel | undefined): Promise<HashViewModel> {
        let url_ = this.baseUrl + "/v1/utils/sha256";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConvertSha256(_response);
        });
    }

    protected processConvertSha256(response: Response): Promise<HashViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HashViewModel;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HashViewModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    generateBcrypt(body: HashViewModel | undefined): Promise<HashViewModel> {
        let url_ = this.baseUrl + "/v1/utils/bcrypt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGenerateBcrypt(_response);
        });
    }

    protected processGenerateBcrypt(response: Response): Promise<HashViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HashViewModel;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HashViewModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    generateArgon2(body: HashViewModel | undefined): Promise<HashViewModel> {
        let url_ = this.baseUrl + "/v1/utils/argon2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGenerateArgon2(_response);
        });
    }

    protected processGenerateArgon2(response: Response): Promise<HashViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HashViewModel;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HashViewModel>(null as any);
    }
}

export interface Account {
    id?: string | null;
    name?: string | null;
    provider?: LoginProvider;
    user_id?: string;
    authorized?: boolean;
    fields?: any | null;
    created?: string;
    updated?: string | null;
}

export interface CryptoViewModel {
    encoded?: string | null;
    decoded?: string | null;
}

export interface File {
    id?: string;
    name?: string | null;
    description?: string | null;
    image_url?: string | null;
    author_id?: string;
    version?: string | null;
    file_url?: string | null;
    raw_size?: number;
    download_count?: number;
    last_download?: string | null;
    created?: string;
    updated?: string | null;
}

export interface Game {
    id?: string;
    name?: string | null;
    description?: string | null;
    type?: number;
    organization_id?: string;
    icon_url?: string | null;
    banner_url?: string | null;
    capsule_image_url?: string | null;
    library_image_url?: string | null;
    parent_id?: string | null;
    slug?: string | null;
    visibility?: number;
    password?: string | null;
    primary?: number;
    game_port?: number | null;
    query_port?: number | null;
    rcon_port?: number | null;
    user_count?: number;
    server_count?: number;
    achievement_count?: number;
    badge_count?: number;
    download_count?: number;
    steam_app_id?: number | null;
    steam_server_app_id?: number | null;
    enable_servers?: boolean;
    rust_gamedig_id?: string | null;
    node_gamedig_id?: string | null;
    server_connect_url?: string | null;
    server_tags?: string | null;
    created?: string;
    updated?: string | null;
}

export interface GameServer {
    id?: string;
    name?: string | null;
    description?: string | null;
    address?: string | null;
    game_port?: number | null;
    query_port?: number;
    game_id?: string;
    game_icon_url?: string | null;
    version?: string | null;
    featured?: number;
    cluster_id?: string | null;
    website_url?: string | null;
    banner_url?: string | null;
    owner_id?: string | null;
    uptime?: number;
    status?: ServerStatus;
    ping?: number | null;
    map?: string | null;
    used_slots?: number | null;
    max_slots?: number | null;
    motd?: string | null;
    players?: string | null;
    last_online?: string | null;
    country?: string | null;
    steam?: number;
    discord_server_id?: string | null;
    youtube_video_url?: string | null;
    tags?: string | null;
    comment_count?: number;
    created?: string;
    updated?: string | null;
}

export interface GameServerCluster {
    id?: string;
    name?: string | null;
    description?: string | null;
    package_id?: string;
    website_url?: string | null;
    banner_url?: string | null;
    owner_id?: string;
    discord_server_id?: string | null;
    youtube_video_url?: string | null;
    tags?: string | null;
    comment_count?: number;
    server_count?: number;
    created?: string;
    updated?: string | null;
}

export interface Group {
    id?: string;
    uuid?: string;
    name?: string | null;
    tag?: string | null;
    description?: string | null;
    type?: number;
    privacy?: number;
    owner_id?: string;
    verified?: boolean;
    photo_url?: string | null;
    banner_url?: string | null;
    member_count?: number;
    follower_count?: number;
    view_count?: number;
    created?: string;
    updated?: string | null;
}

export interface GroupGame {
    group_id?: string;
    game_id?: string;
    stats?: any | null;
    acquired?: string;
    last_used?: string | null;
    group?: Group;
}

export interface GroupMember {
    id?: string;
    uuid?: string;
    name?: string | null;
    display_name?: string | null;
    verified?: boolean;
    photo_url?: string | null;
    last_online?: string | null;
    rank?: GroupRank;
    since?: string;
}

export enum GroupRank {
    Member = "member",
    Leader = "leader",
    Owner = "owner",
}

export interface HashViewModel {
    value?: string | null;
}

export interface LeaderboardItem {
    name?: string | null;
    display_name?: string | null;
    photo_url?: string | null;
    level?: number;
    experience?: number;
    points?: number;
}

export enum LeaderboardOrder {
    Level = "level",
    Points = "points",
}

export enum LoginProvider {
    Steam = "steam",
    Epic = "epic",
    Discord = "discord",
    Microsoft = "microsoft",
    Playstation = "playstation",
    Google = "google",
    Apple = "apple",
}

export interface LoginRequest {
    login?: string | null;
    password?: string | null;
}

export interface LoginResponse {
    user?: UserInfo;
    access_token?: string | null;
    refresh_token?: string | null;
    expires_in?: number;
}

export interface Profile {
    id?: string;
    uuid?: string;
    name?: string | null;
    display_name?: string | null;
    flags?: string;
    verified?: boolean;
    level?: number;
    experience?: number;
    public_birthday?: boolean;
    birthday?: string | null;
    points?: number;
    location?: string | null;
    photo_url?: string | null;
    banner_url?: string | null;
    last_online?: string | null;
    biography?: string | null;
    view_count?: number;
    created?: string;
    updated?: string | null;
}

export interface ProfileGame {
    id?: string;
    name?: string | null;
    capsule_image_url?: string | null;
    library_image_url?: string | null;
    slug?: string | null;
    time_used?: number;
    unlocked_achievements?: number;
    total_achievements?: number;
    stats?: any | null;
    acquired?: string;
    last_used?: string | null;
}

export interface ProfileGroup {
    id?: string;
    uuid?: string;
    name?: string | null;
    tag?: string | null;
    privacy?: number;
    verified?: boolean;
    photo_url?: string | null;
    member_count?: number;
    rank?: GroupRank;
    since?: string;
}

export interface RefreshRequest {
    refresh_token?: string | null;
}

export interface RegisterRequest {
    uuid?: string | null;
    name: string;
    email?: string | null;
    password: string;
}

export interface SearchRequest {
    type?: SearchType;
    query?: string | null;
    page?: number | null;
    game_id?: string | null;
}

export enum SearchType {
    User = "user",
    Group = "group",
    Server = "server",
    Cluster = "cluster",
}

export interface ServerMetrics {
    server_count?: number;
    package_count?: number;
    country_count?: number;
}

export enum ServerStatus {
    Unknown = "unknown",
    Offline = "offline",
    Online = "online",
}

export interface Subscription {
    id?: string;
    name?: string | null;
    description?: string | null;
    image_url?: string | null;
    readonly prices?: { [key: string]: number; } | null;
    created?: string;
    updated?: string | null;
}

export interface UpdateProfile {
    display_name?: string | null;
    biography?: string | null;
}

export interface UserInfo {
    id?: string;
    uuid?: string;
    name?: string | null;
    display_name?: string | null;
    email?: string | null;
    type?: UserType;
    flags?: string;
    permissions?: string;
    verified?: boolean;
    level?: number;
    experience?: number;
    public_birthday?: boolean;
    birthday?: string | null;
    points?: number;
    location?: string | null;
    language?: string | null;
    timezone?: string | null;
    currency?: string | null;
    photo_url?: string | null;
    banner_url?: string | null;
    last_online?: string | null;
    biography?: string | null;
    view_count?: number;
    created?: string;
    updated?: string | null;
}

export enum UserType {
    User = "user",
    Bot = "bot",
    Organization = "organization",
}

export class TribufuApiError extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isTribufuApiError = true;

    static isTribufuApiError(obj: any): obj is TribufuApiError {
        return obj.isTribufuApiError === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new TribufuApiError(message, status, response, headers, null);
}